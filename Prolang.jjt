options
{
    BUILD_PARSER = true;
    JJTREE_OUTPUT_DIRECTORY = "src/wci/frontend";
    NODE_EXTENDS = "wci.intermediate.icodeimpl.ICodeNodeImpl";
    MULTI = true;
    VISITOR = true;
    DEBUG_PARSER=true;
}

PARSER_BEGIN(ProlangParser)
    package wci.frontend;
    import java.util.ArrayList;
    import java.util.HashSet;
    import java.io.*;
    import wci.intermediate.*;
    import wci.intermediate.symtabimpl.*;
    import wci.backend.*;
    import wci.util.*;
    import static wci.intermediate.typeimpl.TypeKeyImpl.*;
    import wci.intermediate.typeimpl.TypeFormImpl;
    import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
    import static wci.intermediate.symtabimpl.DefinitionImpl.*;
    import static wci.intermediate.symtabimpl.RoutineCodeImpl.*;
    import static wci.intermediate.symtabimpl.SymTabKeyImpl.*;
    import static wci.intermediate.icodeimpl.ICodeKeyImpl.*;

public class ProlangParser
{
    private static ArrayList<Integer> counter = new ArrayList<Integer>();
    private static final String SOURCE_SUFFIX = ".prolang";
    private static final String OUTPUT_SUFFIX = ".j";
    private static SymTabStack symTabStack;
    private static SymTabEntry programId;

    public static void main(String [] args) throws Exception
    {
       // Create and initialize the symbol table stack.
        symTabStack = SymTabFactory.createSymTabStack();
        Predefined.initialize(symTabStack);
        counter.add(0);

		//handle source file and output file
        String sourceFilePath = args [0];
        int truncatedLength = sourceFilePath.length() - SOURCE_SUFFIX.length();
        int suffixIndex = sourceFilePath.lastIndexOf(SOURCE_SUFFIX);
        String objectFilePath =
            (suffixIndex == truncatedLength) ?
            sourceFilePath.substring(0, truncatedLength) + OUTPUT_SUFFIX :
            sourceFilePath + OUTPUT_SUFFIX;

      	//Parse 
        Reader reader = new FileReader(sourceFilePath);
        ProlangParser parser = new ProlangParser(reader);
        SimpleNode rootNode = parser.start();
        
        // Print the cross-reference table.
        CrossReferencer crossReferencer = new CrossReferencer();
        crossReferencer.print(symTabStack);

		//vistor
        TypeSetterVisitor typeVisitor = new TypeSetterVisitor();
        rootNode.jjtAccept(typeVisitor, null);

        
        // Create and initialize the ICode wrapper
        ICode iCode = ICodeFactory.createICode();
        iCode.setRoot(rootNode);
        programId.setAttribute(ROUTINE_ICODE, iCode);

        
        // Print the parse tree
        ParseTreePrinter treePrinter = new ParseTreePrinter(System.out);
        treePrinter.print(symTabStack);
        
        // backend
        Backend backend = BackendFactory.createBackend("compile");
        backend.process(iCode, symTabStack, objectFilePath);
    }
}
PARSER_END(ProlangParser)

SKIP:
{
    < IGNORE : [ " ", "\r", "\n", "\t" ] >
        | < "//" (~[ "\n", "\r" ])* >
        | < "/*" > : MULTI_LINE_COMMENT
}

< MULTI_LINE_COMMENT >
SKIP:
{
    "*/" : DEFAULT
}

< MULTI_LINE_COMMENT >
MORE:
{
    < ~[ ] >
}

/***********************************  program  ***************************************************
 program ::= <MINUS> <MODULE> <OPEN_PAREN> <IDENTIFIER> <CLOSE_PAREN> <DOT> <EOF>
**************************************************************************************************/
SimpleNode start() #void :
{
    SimpleNode rootNode = null;
    HashSet syncSet = new HashSet();
    syncSet.add(EOF);
}
{
    try
    {
        <MINUS> <MODULE> <OPEN_PAREN> <IDENTIFIER> 
        {
            programId = symTabStack.enterLocal(token.image);
            programId.setDefinition(DefinitionImpl.MODULE);
            programId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
            symTabStack.setProgramId(programId);
        }
        <CLOSE_PAREN><DOT>
        rootNode = statement_list() <EOF>
        {
            programId.setAttribute(ROUTINE_LOCALS_COUNT, counter.get(0) + 1);
            return rootNode;
        }
    }
    catch (ParseException ex)
    {
        handleError(ex, syncSet, true);
        return null;
    }
}

/***********************************  statement_list  *********************************************
statement_list ::== (statement)*
**************************************************************************************************/
SimpleNode statement_list() :
{}
{
    (statement())*
    {
        return jjtThis;
    }
}

/***********************************  statement  *************************************************
statement ::= ( declaration_statement <DOT> | | assignment_statement<DOT> | if_statement
 						| for_statement | print<DOT> | println <DOT>| function_call<DOT> )
**************************************************************************************************/
void statement() #void :
{
    HashSet syncSet = new HashSet();
    syncSet.add(EOF);
    syncSet.add(DOT);
}
{
    try
    {
          LOOKAHEAD(2) declaration_statement(syncSet) <DOT>
        | LOOKAHEAD(2) assignment_statement(syncSet)  <DOT>
		| if_statement(syncSet)
        | for_statement(syncSet)
        | println(syncSet)
        | print(syncSet)
        | LOOKAHEAD(2) function_call(syncSet) <DOT>
    }
    catch (ParseException ex)
    {
        handleError(ex, syncSet, false);
    }
}

/***********************************  declaration_statement  ***************************************
declaration_statement ::= ( variable_declaration | function_declaration ) 
**************************************************************************************************/
void declaration_statement(HashSet syncSet) #void :
{}
{
    try
    {
        LOOKAHEAD(2) variable_declaration(syncSet) | function_declaration(syncSet)
    }
    catch (ParseException ex)
    {
        handleError(ex, syncSet, false);
    }
}

/***********************************  variable_declaration  ***************************************
 variable_declaration ::= type identifier 
**************************************************************************************************/
void variable_declaration(HashSet syncSet) throws ParseException :
{
    SimpleNode variable_node;
    syncSet.add(EOF);
    syncSet.add(DOT);
}
{
    try {
        (
            type()
            {
                SymTabEntry typeId = symTabStack.lookup(token.image);
                TypeSpec type = typeId.getTypeSpec();
            }
        )
         variable_node = identifier(syncSet, true) {
            SymTabEntry variable_id = (SymTabEntry) variable_node.getAttribute(ID);
            variable_node.setAttribute(ID, variable_id);
            int count = counter.get(counter.size() - 1);
            variable_id.setIndex(count++);
            counter.set(counter.size() - 1, count);
            variable_id.setTypeSpec(type);
            variable_node.setTypeSpec(type);
        }
    }
    catch (ParseException ex) {
        handleError(ex, syncSet, true);
    }
}

/***********************************  function_declaration  ***************************************
 function_declaration ::= <FUNC> identifier <MINUS> <GREATER_THAN> <parameterList >
 							return code_block
**************************************************************************************************/
void function_declaration(HashSet syncSet):
{
    SimpleNode variable_node;
    SimpleNode returnTypeNode;
    syncSet.add(FUNC); 
}
{
    try {
        <FUNC> {
            syncSet.remove(FUNC);
        }
        variable_node = identifier(syncSet, true) {
            SymTabEntry functionId = (SymTabEntry) variable_node.getAttribute(ID);
            functionId.setDefinition(DefinitionImpl.FUNCTION);
            functionId.setAttribute(ROUTINE_SYMTAB, symTabStack.push());
            variable_node.setAttribute(ID, functionId);
            jjtThis.setAttribute(ID, functionId);
            counter.add(0);
        }
        <MINUS> <GREATER_THAN>
        <OPEN_PAREN> parameterList(syncSet) <CLOSE_PAREN> returnTypeNode = returnType() {
            functionId.setTypeSpec(returnTypeNode.getTypeSpec());
            jjtThis.setTypeSpec(functionId.getTypeSpec());
            syncSet = new HashSet(); 
            syncSet.add(EOF);
            syncSet.add(DOT);
            counter.remove(counter.size() - 1);
        }
        block(syncSet) {
            symTabStack.pop();
        }
    }
    catch (ParseException ex) {
        handleError(ex, syncSet, true);
    }
}

/***********************************  parameterList  *********************************************
 parameterList ::= (parameter (<COMMA> parameter)*)?
**************************************************************************************************/
void parameterList(HashSet syncSet) : {}
{
    (parameter(syncSet) ( <COMMA> parameter(syncSet))*)?
}

/***********************************  parameter  *************************************************
 parameter ::= type ( <MULTIPLY>)? identifier
**************************************************************************************************/
void parameter(HashSet syncSet) throws ParseException :
{
    SimpleNode variable_node;
    syncSet.add(EOF);
    syncSet.add(DOT);
    int ref = 0;
}
{
    try {
         (
            type()
            {
                SymTabEntry typeId = symTabStack.lookup(token.image);
                TypeSpec type = typeId.getTypeSpec();
            }
        )
                (
            <MULTIPLY> {
              ref = 1;
        
            }
        )?
        variable_node = identifier(syncSet, true) {
            SymTabEntry variable_id = (SymTabEntry) variable_node.getAttribute(ID);
            variable_id.setTypeSpec(type);
            variable_node.setAttribute(ID, variable_id);
            variable_node.setTypeSpec(type);
            int count = counter.get(counter.size() - 1);
            variable_id.setIndex(count++);
            counter.set(counter.size() - 1, count);
			//set reference
            if(ref == 1)            {
              variable_id.setDefinition(DefinitionImpl.REFERENCE_PARAMETER);			}
			else			{
			  variable_id.setDefinition(DefinitionImpl.VALUE_PARAMETER); 			}      
        }
    }
    catch (ParseException ex) {
        handleError(ex, syncSet, true);
    }
}

/***********************************  function_call  **********************************************
function_call ::= IDENTIFIER <OPEN_PAREN> expression <CLOSE_PAREN>
**************************************************************************************************/
void function_call(HashSet syncSet) :
{
    SimpleNode function_node;
    SymTabEntry function_name;
}
{
    try {
        function_node = identifier(syncSet, false) {
            function_name = (SymTabEntry) function_node.getAttribute(ID);
            jjtThis.setTypeSpec(function_node.getTypeSpec());

            if (function_name != null) {
                jjtThis.setAttribute(ID, function_name);
            }
            else {
                throw new ParseException("ERROR: Function not declared in scope.");
            }
        }
        <OPEN_PAREN> (expression(syncSet) (<COMMA> expression(syncSet))*)? <CLOSE_PAREN>
    }
    catch (ParseException ex) {
        handleError(ex, syncSet, true);
    }
}

/***********************************  block  *****************************************************
block ::= <OPEN_BRACE> statement_list <CLOSE_BRACE>
**************************************************************************************************/
void block(HashSet syncSet) : {}
{
    {
        syncSet.add(CLOSE_BRACE);
    }
    try
    {
        <OPEN_BRACE> statement_list() <CLOSE_BRACE>
    }
    catch (ParseException ex)
    {
        handleError(ex, syncSet, true);
    }
    finally {
        syncSet.remove(CLOSE_BRACE);
    }
}

/***********************************  if_statement  ***********************************************
if_statement ::= <IF> expression <THEN> block (else_statement)?
**************************************************************************************************/
void if_statement(HashSet syncSet) : { syncSet.add(IF); }
{
    try
    {
        <IF> expression(syncSet) <THEN> block(syncSet) (else_statement(syncSet))?
    }
    catch (ParseException ex)
    {
        handleError(ex, syncSet, true);
    }
    finally
    {
        syncSet.remove(IF);
    }
}

/***********************************  else_statement  *********************************************
else_statement ::= <ELSE> if_statement | block 
**************************************************************************************************/
void else_statement(HashSet syncSet) : { syncSet.add(ELSE); }
{
    try
    {
        <ELSE> (
            LOOKAHEAD(2) if_statement(syncSet) | block(syncSet)
        )
    }
    catch (ParseException ex)
    {
        handleError(ex, syncSet, true);
    }
    finally
    {
        syncSet.remove(ELSE);
    }
}

/***********************************  assignment_statement  ***************************************
assignment_statement ::= identifier <EQUAL> expression 
**************************************************************************************************/
void assignment_statement(HashSet syncSet) : { SimpleNode variable_node; }
{
    variable_node = identifier(syncSet, false)
    {
        SymTabEntry variable_id = symTabStack.lookup(token.image);
        TypeSpec typeId = variable_id.getTypeSpec();
        variable_node.setAttribute(ID, variable_id);
    }
    <EQUALS> expression(syncSet)
}

/***********************************  for_statement  **********************************************
for_statement ::= <FOR> for_header block()
**************************************************************************************************/
void for_statement(HashSet syncSet) : {}
{
    <FOR> for_header() block(syncSet)
}

/***********************************  for_clause  *************************************************
for_clause ::= assignment_statement <DOT> expression <DOT> assignment_statement <DOT>
**************************************************************************************************/
void for_header() : {
    HashSet syncSet = new HashSet();
    syncSet.add(EOF);
    syncSet.add(DOT);
    syncSet.add(FOR);
}
{
    try {
        (LOOKAHEAD(2) (assignment_statement(syncSet) <DOT> expression(syncSet) <DOT>
                           assignment_statement(syncSet)<DOT>)
        |
        expression(syncSet))
    }
    catch (ParseException ex) {
        handleError(ex, syncSet, true);
    }
    finally {
        syncSet.remove(FOR);
    }
}

/***********************************  operand  ***************************************************
operand ::= identifier | integerConstant | realConStant | booleanConstant | string |
             <OPEN_PAREN> expression <CLOSE_PAREN >
**************************************************************************************************/
void operand(HashSet syncSet) #void : {}
{
    (
        (
            identifier(syncSet, false) | LOOKAHEAD(2) integerConstant() | LOOKAHEAD(2) realConstant()
            | booleanConstant() | interpretedString()
        )
        | <OPEN_PAREN> expression(syncSet) <CLOSE_PAREN>
    )
}

/***********************************  relational_operators  ***************************************
relational_operators ::= < EQUAL_EQUAL > | < NOT_EQUAL > | < LESS_THAN > | < LESS_EQUAL >
                        | < GREATER_THAN > | < GREATER_EQUAL >
**************************************************************************************************/
void relational_operators() #void : {}
{
    < EQUAL_EQUAL > | < NOT_EQUAL > | < LESS_THAN > | < LESS_EQUAL > | < GREATER_THAN > | < GREATER_EQUAL >
}

/***********************************  expression  ************************************************
expression ::= term (<EQUAL_EQUAL> | <NOT_EQUAL> | <LESS_THAN>  | <GREATER_THAN> |  <PLUS>
   			   	|  <GREATER_EQUAL> | <PLUS> | <MINUS>)*
**************************************************************************************************/
void expression(HashSet syncSet) #void : {}
{
    term(syncSet) (
          <EQUAL_EQUAL> term(syncSet) #equalEqual(2)
        | <NOT_EQUAL> term(syncSet) #notEqual(2)
        | <LESS_THAN> term(syncSet) #lessThan(2)
        | <LESS_EQUAL> term(syncSet) #lessEqual(2)
        | <GREATER_THAN> term(syncSet) #greaterThan(2)
        | <GREATER_EQUAL> term(syncSet) #greaterEqual(2)
        | <PLUS> term(syncSet) #add(2)
        | <MINUS> term(syncSet) #subtract(2)
    )*
}

/***********************************  term  ******************************************************
term ::= operand (<MULTIPLY> operand | <DIVIDE> operand | <MODULO> operand )*
**************************************************************************************************/
void term(HashSet syncSet) #void : {}
{
    operand(syncSet) (
          <MULTIPLY> operand(syncSet) #multiply(2)
        | <MODULO> operand(syncSet) #modulo(2)
        | <DIVIDE> operand(syncSet) #divide(2)
        
    )*
}

/***********************************  expressionList  ********************************************
expressionList ::= expression (<COMMA> expression)*
**************************************************************************************************/
void expressionList(HashSet syncSet) : {}
{
    expression(syncSet) ( <COMMA> expression(syncSet))*
}

/***********************************  println  *********************************************
println ::= io:fwrite <OPEN_PAREN> expression <CLOSE_PAREN> <DOT>
**************************************************************************************************/
void println(HashSet syncSet) #println : {}
{
    "io:fwriteln" <OPEN_PAREN> expression(syncSet) <CLOSE_PAREN><DOT>
}

/***********************************  print  *********************************************
print ::= io:fwrite <OPEN_PAREN> expression <CLOSE_PAREN> <DOT>
**************************************************************************************************/
void print(HashSet syncSet) #print:
{}
{
    "io:fwrite" <OPEN_PAREN> expression(syncSet) <CLOSE_PAREN><DOT>
}

/***********************************  identifier  ***********************************************
identifier ::= identifier
**************************************************************************************************/
SimpleNode identifier(HashSet syncSet, boolean declaring) : {}
{
    try {
        <IDENTIFIER>
        {
            SymTabEntry variable_id = symTabStack.lookup(token.image);

            if (declaring) {
                variable_id = symTabStack.lookupLocal(token.image);
                if (variable_id != null) {
                    throw new ParseException("ERROR: Variable already declared in scope.");
                }

                variable_id = symTabStack.enterLocal(token.image);
                variable_id.appendLineNumber(token.beginLine);
                variable_id.setDefinition(DefinitionImpl.VARIABLE);
                jjtThis.setAttribute(ID, variable_id);
            }
            else if (variable_id != null) {
                variable_id.appendLineNumber(token.beginLine);
                TypeSpec type = variable_id.getTypeSpec();
                jjtThis.setTypeSpec(type);
                jjtThis.setAttribute(ID, variable_id);
            }
            else {
                throw new ParseException("ERROR: Variable has not been declared in scope.");
            }

            return jjtThis;
        }
    }
    catch (ParseException ex) {
        handleError(ex, syncSet, true);
    }
}

/*********************************** integerConstant   *******************************************
integerConstant ::= <INTEGER_NUMBER>
**************************************************************************************************/
void integerConstant() : {}
{
    <INTEGER_NUMBER>
    {
        jjtThis.setTypeSpec(Predefined.integerType);
        jjtThis.setAttribute(VALUE, Integer.parseInt(token.image));
    }
}

/***********************************  voidConstant  **********************************************
voidConstant ::= <VOID>
**************************************************************************************************/
void voidConstant() : {}
{
    <VOID>
    {
        jjtThis.setTypeSpec(Predefined.voidType);
    }
}

/***********************************  booleanConstant  *******************************************
booleanConstant ::= <BOOL_CONSTANT>
**************************************************************************************************/
void booleanConstant() : {}
{
    < BOOL_CONSTANT >
    {
        jjtThis.setTypeSpec(Predefined.booleanType);
        if (token.image.equals("true")) {
            jjtThis.setAttribute(VALUE, "true");
        }
        else {
            jjtThis.setAttribute(VALUE, "false");
        }
    }
}

/*********************************** realConstant   **********************************************
realConstant ::= <REAL_NUMBER>
**************************************************************************************************/
void realConstant() : {}
{
    <REAL_NUMBER>
    {
        jjtThis.setTypeSpec(Predefined.realType);
        jjtThis.setAttribute(VALUE, Float.parseFloat(token.image));
    }
}

/***********************************  interpretedString  *****************************************
interpretedString ::= <INTERPRE
**************************************************************************************************/
void interpretedString() : {}
{
    < INTERPRETED_STRING >
    {
        jjtThis.setTypeSpec(Predefined.charType);
        jjtThis.setAttribute(VALUE, token.image.toString());
    }
}

/***********************************  type  ******************************************************
type ::= INT | FLOAT | STRING | BOOL
**************************************************************************************************/
void type() #void : {}
{
    <INT> | <FLOAT> | <STRING> | <BOOL>
}

/***********************************  returnType  ************************************************
returnType ::= INT | FLOAT | STRING | BOOL | VOID
**************************************************************************************************/
SimpleNode returnType() : {}
{
    (<INT> | <FLOAT> | <STRING> | <BOOL> | <VOID>) {
        SymTabEntry typeId = symTabStack.lookup(token.image);
        jjtThis.setTypeSpec(typeId.getTypeSpec());
        return jjtThis;
    }
}

/***********************************  TOKEN  ************************************************
**************************************************************************************************/

TOKEN: {
      <BREAK: "break">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <DEFAULT_TOKEN: "default">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <FUNC: "function">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <ELSE: "else">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <MODULE: "module">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <IF: "if">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <THEN: "then">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <CONTINUE: "continue">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <FOR: "for">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <RETURN: "return">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <INT: "int">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <FLOAT: "float">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <STRING: "string">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <BOOL: "bool">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <VAR: "var">
        {debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
      | <VOID: "void">
        { debugStream.println("RESERVED_WORD token: " + matchedToken.image); }
}

TOKEN: {
    <#NEWLINE : [ "\r", "\n" ] >
    | <#WHITE_SPACE : < NEWLINE > | "\t" | " " >
    | <SEMICOLON : ";" >
    | <COMMA : "," >
    | <DOT: ".">
    | <OPEN_PAREN: "(">
        {debugStream.println("OPEN_PAREN token: " + matchedToken.image); }
    | <CLOSE_PAREN: ")">
        {debugStream.println("CLOSE_PAREN token: " + matchedToken.image); }
    | <OPEN_BRACE: "{">
        {debugStream.println("OPEN_BRACE token: " + matchedToken.image); }
    | <CLOSE_BRACE: "}">
        {debugStream.println("CLOSE_BRACE token: " + matchedToken.image); }
    | <OPEN_BRACKET: "[">
        {debugStream.println("OPEN_BRACKET token: " + matchedToken.image); }
    | <CLOSE_BRACKET: "]">
        {debugStream.println("CLOSE_BRACKET token: " + matchedToken.image); }
}

TOKEN: {
    <PLUS: "+">
        {debugStream.println("PLUS token: " + matchedToken.image); }
    |
    <INCREMENT: "++">
        {debugStream.println("INCREMENT token: " + matchedToken.image); }
    |
    <DECREMENT: "--">
        {debugStream.println("DECREMENT token: " + matchedToken.image); }
    | <MINUS: "-">
        {debugStream.println("MINUS token: " + matchedToken.image); }
    | <MULTIPLY: "*">
        {debugStream.println("MULTIPLY token: " + matchedToken.image); }
    | <DIVIDE: "/">
        {debugStream.println("DIVIDE token: " + matchedToken.image); }
    | <MODULO: "%">
        {debugStream.println("MODULO token: " + matchedToken.image); }
    | <STAR_EQUAL: "*=">
        {debugStream.println("STAR_EQUALS token: " + matchedToken.image); }
    | <DIVIDE_EQUAL: "/=">
        {debugStream.println("DIVIDE_EQUALS token: " + matchedToken.image); }
    | <MODULO_EQUAL: "%=">
        {debugStream.println("MODULO_EQUALS token: " + matchedToken.image); }
    | <EQUALS: "=">
        {debugStream.println("EQUALS token: " + matchedToken.image); }
    | <EQUAL_EQUAL: "==">
        {debugStream.println("EQUAL_EQUAL token: " + matchedToken.image); }
    | <PLUS_EQUAL: "+=">
        {debugStream.println("PLUS_EQUAL token: " + matchedToken.image); }
    | <MINUS_EQUAL: "-=">
        {debugStream.println("MINUS_EQUAL token: " + matchedToken.image); }
    | <LESS_THAN: "<">
        {debugStream.println("LESS_THAN token: " + matchedToken.image); }
    | <GREATER_THAN: ">">
        {debugStream.println("GREATER_THAN token: " + matchedToken.image); }
    | <LESS_EQUAL: "<=">
        {debugStream.println("LESS_EQUALS token: " + matchedToken.image); }
    | <GREATER_EQUAL: ">=">
        {debugStream.println("GREATER_EQUALS token: " + matchedToken.image); }
    | <OR: "||">
        {debugStream.println("OR_OR token: " + matchedToken.image); }
    | <AND: "&&">
        {debugStream.println("AND_AND token: " + matchedToken.image); }
    | <NOT_EQUAL: "!=">
        {debugStream.println("NOT_EQUALS token: " + matchedToken.image); }
    | <NOT: "!">
        {debugStream.println("NOT token: " + matchedToken.image); }
}

TOKEN :
{
      <INTEGER_NUMBER: ("-")? (<DIGIT>)+ >
        { debugStream.println("INTEGER_NUMBER token: " + matchedToken.image); }
      | < REAL_NUMBER : < INTEGER_NUMBER > ("." < INTEGER_NUMBER >)? >
        { debugStream.println("REAL_NUMBER token: " + matchedToken.image); }
      | < BOOL_CONSTANT : ( "true" | "false")>
        { debugStream.println("BOOL_CONSTANT token: " + matchedToken.image); }
      | < INTERPRETED_STRING : "\"" ( < ALPHANUMERIC > | < ESCAPED_CHAR >
             | < INTERPRETED_LITERAL_SYMBOL > | < WHITE_SPACE >)* "\"" >
        { debugStream.println("INTERPRETED_STRING token: " + matchedToken.image); }
      | < IDENTIFIER : (< UPPER_CHAR > | "_") ( < LETTER > | < DIGIT > | "_")* >
        { debugStream.println("IDENTIFIER token: " + matchedToken.image); }
      | < #ALPHANUMERIC : ( < LETTER > | < DIGIT >)+ >
      | < #ESCAPED_CHAR : "\\" ( "a" | "b" | "f" | "n" | "r" | "t" | "v" | "\\" | "'" | "\"") >
      | < #LETTER : [ "a"-"z", "A"-"Z" ] >
      | < UPPER_CHAR : ["A"-"Z"] >
      | < #DIGIT : [ "0"-"9" ] >
      |
      <#INTERPRETED_LITERAL_SYMBOL : "'" | "~" | "!" | "@" | "#" | "$" | "%" | "^" | "&"
      | "*" | "_" | "-" | "+" | "=" | "<" | ">" | "." | "/" | "?" | ","
      | ";" | "(" | ")" | "[" | "]" | "{" | "}" | "|" | "`" | ":">
}

TOKEN: { /* Error token */
    <ERROR : ~["\r", "\n"]>
}

JAVACODE String handleError(ParseException ex, HashSet syncSet, boolean doPop) #void
{
  	System.out.println("error here");
    Token token = ex.currentToken;
    System.out.println(ex.getMessage());

    while (!syncSet.contains(getToken(1).kind)) {
        token = getNextToken();
    }

    if (doPop) jjtree.popNode();
    return token.image;
}
